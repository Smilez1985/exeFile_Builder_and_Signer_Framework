import datetime
from pathlib import Path
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from src.utils.logger import log

class CertManager:
    """
    Erstellt professionelle X.509 Zertifikate mittels OpenSSL-Standards (via cryptography Lib).
    Erstellt PFX (PKCS#12) f端r Windows Signierung.
    """

    def __init__(self, cert_dir: Path):
        self.cert_dir = cert_dir
        self.cert_dir.mkdir(parents=True, exist_ok=True)

    def list_certs(self):
        return list(self.cert_dir.glob("*.pfx"))

    def create_certificate(self, name: str, password: str, valid_days=3650) -> tuple[Path, Path]:
        """
        Erstellt Private Key & Self-Signed Certificate und packt es in eine PFX.
        """
        log.info(f"Generiere kryptografisches Schl端sselpaar f端r '{name}'...")

        # 1. Private Key generieren (RSA 4096 bit - High Security)
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096,
        )

        # 2. Zertifikat erstellen
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, u"DE"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u"ExeBuilder Framework User"),
            x509.NameAttribute(NameOID.COMMON_NAME, name),
        ])

        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.datetime.utcnow()
        ).not_valid_after(
            datetime.datetime.utcnow() + datetime.timedelta(days=valid_days)
        ).add_extension(
            x509.ExtendedKeyUsage([x509.OID_CODE_SIGNING]),
            critical=True,
        ).sign(private_key, hashes.SHA256())

        # 3. Speichern als PFX (PKCS12)
        pfx_path = self.cert_dir / f"{name}.pfx"
        cer_path = self.cert_dir / f"{name}.cer"

        # CER (Public Key) speichern
        with open(cer_path, "wb") as f:
            f.write(cert.public_bytes(serialization.Encoding.DER))

        # PFX (Private + Public) speichern
        pfx_data = serialization.pkcs12.serialize_key_and_certificates(
            name=name.encode('utf-8'),
            key=private_key,
            cert=cert,
            cas=None,
            encryption_algorithm=serialization.BestAvailableEncryption(password.encode('utf-8'))
        )

        with open(pfx_path, "wb") as f:
            f.write(pfx_data)

        log.success(f"Zertifikat erfolgreich generiert: {pfx_path}")
        return pfx_path, cer_path

    def generate_install_script(self, output_dir: Path, cert_name: str, cer_file: Path):
        """Erstellt Batch-Skript f端r Kundeninstallation."""
        bat_path = output_dir / "install_certificate.bat"
        content = f"""@echo off
:: Auto-Generated by ExeFile Builder Framework
title Zertifikat Installation - {cert_name}
echo --------------------------------------------------
echo Installiere Zertifikat fuer: {cert_name}
echo Benoetigt Administrator-Rechte.
echo --------------------------------------------------
certutil -addstore -f "TrustedPeople" "%~dp0{cer_file.name}"
certutil -addstore -f "Root" "%~dp0{cer_file.name}"
echo.
if %errorlevel% equ 0 (
    echo SUCCESS: Zertifikat wurde installiert.
) else (
    echo ERROR: Installation fehlgeschlagen. Admin Rechte pruefen.
)
pause
"""
        with open(bat_path, "w") as f:
            f.write(content)
        log.info(f"Install-Script erstellt: {bat_path}")
